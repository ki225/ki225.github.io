---
title: 通訊的鏈路層
date: 2025-10-20 13:53:52
tags: [wireless, link layer]
---

## Error control


### 錯誤控制的目標

確保資料傳輸具有以下特性：

| 性質                 | 說明                   |
| ------------------ | -------------------- |
| **Error-free**     | 無錯誤傳輸（收到的資料 = 發送的資料） |
| **In-sequence**    | 順序正確                 |
| **Duplicate-free** | 不重複（每封包僅一次）          |
| **Loss-free**      | 不遺失（確保至少傳送一次）        |


### 錯誤來源與挑戰

| 來源                          | 說明                        |
| --------------------------- | ------------------------- |
| **Fading**                  | 訊號衰落                      |
| **Interference**            | 來自其他發射源的干擾                |
| **Loss of synchronization** | 位元同步錯誤                    |
| **結果**                      | 位元錯誤率高（BER 約可達 10⁻²～10⁻⁴） |


### 錯誤控制方法分類

| 方法      | 全名                               | 原理               |
| ------- | -------------------------------- | ---------------- |
| **ARQ** | Automatic Repeat reQuest（回傳重傳）   | 發現錯誤 → 要求重傳(事後修補)      |
| **FEC** | Forward Error Correction（前向錯誤更正） | 加入冗餘碼 → 自行修正少量錯誤(事前預防) |


### Backward Error Control（事後處理）
基本上就是實現先前提到的特性(Duplicate-free、in-sequence、error-free、loss-free)，每個特性的實現方式如下：
- Duplicate-free、in-sequence：在資料本體（payload）外加入標頭資訊
- error-free：計算封包的檢查碼（checksum）並附加在封包中，通常使用循環冗餘檢查（CRC, Cyclic Redundancy Check），速度快、額外負擔小。
- loss-free：由接收端回饋傳送狀態給發送端，狀態包含正向或負向回覆（ACK／NACK），傳送端使用計時器（timer）來偵測是否未收到回覆。
  - 但多數情況不會使用 Nack 封包，是為了節省通訊資源
  - 若設定了最大重傳次數限制，則此協定最多只能達到**半可靠（semi-reliable）**的傳輸。


#### 常見 ARQ 協定比較

| 協定名稱                               | 原理                                  | 優點       | 缺點                        |
| ---------------------------------- | ----------------------------------- | -------- | ------------------------- |
| **ABP (Alternating Bit Protocol)** | 每次只發送一個封包，使用 1-bit 序號（0/1）區分新舊封包    | 簡單、保證順序  | 效率低，只能單封包往返               |
| **Go-Back-N**                      | 發送端可連續傳送 N 個封包，若其中一個錯誤 → 重傳從該點後所有封包 | 實作簡單     | 浪費頻寬（因連帶重傳）               |
| **Selective Repeat (SR)**          | 只重傳錯誤的封包，其他保留                       | 效率高、節省頻寬 | 實作複雜（需緩衝 out-of-order 封包） |

會發現其實 Go-back-n 和 SR 非常的相似，都妥善的應用了 channel，那為什麼不用 SR 就好了呢? 其實選擇使用哪一個是根據 receiver 端的狀態去決定，如果接收端能力較弱，就選擇 Go-back-n，反之選 SR。

#### ACK/NACK 使用策略

| 策略                      | 說明           | 取捨                 | tradeoff |
| ----------------------- | --------------- | ------------------ | ---------------------|
| **Cumulative ACK**      | 一次確認多個封包  | 減少 ACK 數量，但需緩衝更多資料 | buffer space, Nack 的數量|
| **Individual ACK**      | 每封包都回覆     | 簡單但增加控制流量          |
| **Negative ACK (NACK)** | 僅回覆錯誤封包   | 節省頻寬但需良好同步機制       |



#### 何時重傳（Retransmission Decision）

| 問題               | 處理策略                                                                                |
| ---------------- | ----------------------------------------------------------------------------------- |
| **通道衰落時是否立即重傳？** | 建議暫緩（避免在壞通道浪費傳輸）                                                                    |
| **等待多久？**        | 可用 **Probing Protocol**：<br>當錯誤發生 → 進入 probing 模式，定期傳送短封包測試通道 → 通道恢復後再回到 normal 模式。 |



### Forward Error Control（FEC 前向錯誤更正）
FEC 是在傳送端對資料加入**冗餘位元**進行編碼做容錯，讓接收端在不重傳的情況下自行修正少量錯誤。通常會根據 channel 狀態來決定編碼方式

![alt text](images/wireless/img4.png)

其中上圖的 Inter-leaver 是源自一個奇妙的觀察，發現先打亂原本要送出的封包，讓他變得不連續，反而讓接收端可以更好的找到所有的封包。

#### Block-coded FEC（區塊編碼）
在這種 FEC 機制中，其中有種方式為區塊編碼，也就是說資料是以「區塊 (block)」為單位進行編碼，核心原理是在傳送數據時將資料分成固定大小的區塊，並在每個區塊中加入額外的冗餘資料。每個區塊包含 𝑘 個原始符號（source symbols），這些符號不一定只是位元（bits），也可能是更大的單位（稱為 p 元符號，p-ary symbols）。編碼器會將這 𝑘 個符號轉換成 𝑛 個通道符號（channel symbols），也就是在原本的資料中加入冗餘（redundancy）以便錯誤更正。

為了能修正最多 𝑡 個位元錯誤，必須滿足 漢明界限 (Hamming Bound):
$2^{n - k} \ge \sum_{i=0}^{t} \binom{n}{i}$

- 左邊：$(2^{n-k})$ → 可用來識別錯誤的「檢查模式」數量（由冗餘位元提供的辨識能力）。
- 右邊：$(\sum_{i=0}^{t}\binom{n}{i})$ → 在一個碼字中，若最多可容忍 (t) 個錯誤，則可能出錯的情形數量。


常見的 block-coded FEC 包含
- Reed-Solomon (RS)
- BCH (Bose–Chaudhuri–Hocquenghem)


以下圖進行說明，紅色是無額外編碼的情形，可以看到當 channel 狀態良好的時候，他耗能最小，反而是橘色的線因為編碼複雜而耗更多能；但當 channel 狀態不好時，就會看到橘色線是耗能最少的

![alt text](images/wireless/img6.png)


####  Convolutional Codes（卷積編碼）
另一種 FEC 是卷積編碼，輸出的編碼位元（code bits）取決於目前的輸入與前面 K−1 個輸入（每次輸入包含 k 個使用者位元）。

這種編碼的碼率為 𝑅 = 𝑘/𝑛，代表每 𝑘 個使用者位元會被映射成 𝑛 個編碼位元。編碼過程所需的能量成本很低（Encoding: cheap）。

### FEC vs. ARQ 比較

| 項目    | **FEC**                      | **ARQ**          |
| ----- | ---------------------------- | ---------------- |
| 原理    | 加入冗餘，自行修正                    | 錯誤回報並重傳          |
| 傳輸開銷  | 固定開銷（每封包都編碼）                 | 僅錯誤時才重傳          |
| 延遲    | 低（無需等待 ACK）                  | 高（需等待回報）         |
| 通道適應性 | 不易動態調整                       | 可根據錯誤即時反應        |
| 適合環境  | 高延遲或不穩定通道（如衛星）               | 穩定、低延遲通道（如 WLAN） |

但通常會視情形混和兩者方法去使用(hybrid schemes)

## 功率控制（Power Control）

另一個可控制的參數是傳輸功率（transmission power）。
- 功率提高 → 錯誤率降低 → 所需的 FEC/ARQ 次數減少。
- 功率降低 → 錯誤率上升 → 需要更強的 FEC 來維持可靠性。

## Framing
### 封包大小的取捨

| 封包大小                   | 優點              | 缺點                 |
| ---------------------- | --------------- | ------------------ |
| **小封包（Small packets）** | 錯誤率低（因較短、出錯機率小） | 封包化開銷高（header 比例大） |
| **大封包（Large packets）** | 開銷低（header 比例小） | 錯誤率高（封包越長越容易出錯）    |

已知 h(overhead, payload size, Bit error rate (BER)) 如下，且縱軸是花的能量。可以看到左圖紅線因為拆成多個封包，所以封包 header 多，導致在 channel 良好的時候耗能多；但當 channel 狀態不好(bit error rate 上升後)的時候就會是綠線耗能多。  

![alt text](images/wireless/img7.png)

總之就是隨情況而改變封包方式，當 channel 狀態好，就用大封包；反之用小封包。

### 動態調整訊框長度（Dynamically Adapt Frame Length）
- 已知 BER 時
  - 最佳訊框長度可直接根據理論公式求得
- 不知 BER 時
  - 如何估計 BER？
    1. 在接收端蒐集通道狀態資訊（Channel State Information, CSI）
      - RSSI（Received Signal Strength Indicator）
      - FEC 解碼統計（decoder error info）
    2. 重傳統計


## Link management
上面的部份我們討論了底層可以如何設計讓封包在 link 內可以更順利，接著這章節要說明在 link 層要怎麼樣幫封包分辨好的和壞的鏈路並使用，也就是決定節點應與哪些「鄰居（neighbor）」保持連線，確保可達性（reachability）與通訊品質（communication quality）。

在這部分可以探討的問題包含了：
| 問題來源                         | 說明                       |
| ---------------------------- | ------------------------ |
| **通訊品質不穩定**                  | 無線通道容易受干擾與環境影響而波動。       |
| **遠距離節點傳輸成本高**               | 傳輸功率大、能量消耗高。             |
| **高錯誤率（error-prone）**        | 封包丟失與錯誤傳輸頻繁。             |
| **品質僅能估測（estimation-based）** | 無法直接測得真實通道品質，只能根據統計結果判斷。 |

### 鄰居表（Neighborhood Table）
- 每個節點維護一份鄰居清單（neighborhood table）。
- 表中紀錄每個鄰居的通訊品質與連線狀態。
- 通常由 MAC 層協定（如 CSMA/CA）半自動建立與更新。

### Link Quality Characteristics（鏈路品質特性）
理想中我們會認為通訊範圍呈「圓形」，隨著半徑增加通訊品質逐漸下降，但現實世界有更多的干擾、區域邊界不規則、非對稱、不穩定等，這些原因導致：
1. 距離與封包遺失率（Loss Rate）關聯性弱
2. 等損耗線（iso-loss lines） 不呈圓形，而是不規則形狀
3. 鏈路不對稱現象常見（約 15%）：A 傳得到 B，但 B 傳不到 A
4. 即使節點靜止，短期內 PER（Packet Error Rate）仍劇烈變化

### Three Regions of Communication（三種通訊區域）
| 區域                            | 特性                   | 封包錯誤率 (PER)     |
| ----------------------------- | -------------------- | --------------- |
| **Effective Region（有效區域）**    | 穩定通訊，品質佳             | PER < 10%       |
| **Transitional Region（過渡區域）** | 不穩定、波動大，同距離節點表現差異可很大 | 10% ≦ PER ≦ 90% |
| **Poor Region（低品質區域）**        | 幾乎無法通訊               | PER > 90%       |

### Link Quality Estimation（鏈路品質估測）
為了在線（on-line）評估實際鏈路品質，以調整傳輸策略，測量鏈路品質的工具必須具備以下特性
| 特性                 | 說明                    |
| ------------------ | --------------------- |
| **Precision（精確度）** | 應給出統計上合理的估測結果。        |
| **Agility（敏捷度）**   | 能快速反應通道品質的變化。         |
| **Stability（穩定性）** | 不被短期波動（瞬時異常）誤導。       |
| **Efficiency（效率）** | 應盡量降低估測開銷（可為主動或被動方式）。 |

#### WMEWMA（Window Mean Exponentially Weighted Moving Average）
在無線網路（特別是感測網路、Mesh、Ad-hoc）中，通道品質會隨時間變化（例如干擾、遮蔽、距離）。因此節點必須**即時估計「鏈路品質」**來決定是否重傳封包（ARQ）、是否切換連線對象（link switch）、或調整封包長度與功率。

$P_n = \alpha P_{n-1} + (1 - \alpha) \frac{r_n}{r_n + f_n}$

| 符號        | 意義                            |
| --------- | ----------------------------- |
| $P_n$     | 當前估計的鏈路品質（第 n 次更新）            |
| $P_{n-1}$ | 前一次估計的鏈路品質                    |
| $\alpha$  | 平滑係數（0～1 之間），控制「穩定 vs. 敏捷」的取捨 |
| $r_n$     | 在此時間區間內**成功接收的封包數**           |
| $f_n$     | 在此時間區間內**遺失的封包數（即 gap 數）**    |

1. **Window Mean（窗口平均）**：在固定時間窗口內統計成功率
   $\text{成功率} = \frac{r_n}{r_n + f_n}$
2. **EWMA（指數加權移動平均）**：平滑過去與現在的估測值
   $P_n = \alpha P_{n-1} + (1 - \alpha)\text{(當前平均)}$

這是一個 **加權移動平均（Exponential Weighted Moving Average, EWMA）** 的形式。

* $\frac{r_n}{r_n + f_n}$ ：代表最近一段時間的「封包成功率」。
* $\alpha P_{n-1}$：代表「過去的估測結果」——用來保持穩定。
* $(1 - \alpha)$：代表「新資料的權重」——用來反映變化。

因此：

> (P_n) 是一個「平滑更新的封包成功率」，
> 可視為**實時的鏈路品質指標（Link Quality Indicator, LQI）**。

| $\alpha$ 值  | 反應特性               |
| ----------- | ------------------ |
| **大（接近 1）** | 估測穩定、但反應慢（適合平穩環境）  |
| **小（接近 0）** | 反應快、但波動大（適合快速變動通道） |

> 每當收到一個封包時，節點根據成功與遺失封包的比例更新 (P_n)，
> 藉此持續估計目前鏈路的可靠程度。


![alt text](images/wireless/img8.png)

上方綠色的方塊代表「成功收到的封包」，
方塊上的數字（7、10、11、15）是**封包序號（packet sequence number）**。

中間標註的 “Gap” 表示：**中間缺少的封包數量**（即有幾個封包遺失）。
例如：

* 收到封包 7 之後，下一個是 10 → **Gap = 2**（表示封包 8、9 遺失）
* 收到 10 → 11 → Gap = 0（連續）
* 收到 11 → 15 → **Gap = 3**（封包 12、13、14 遺失）
